#include <types.h>
#include <coremap.h>
#include <kern/errno.h>
#include <lib.h>
#include <thread.h>
#include <curthread.h>
#include <addrspace.h>
#include <vm.h>
#include <array.h>
#include <machine/tlb.h>
#include <machine/vm.h>
#include <synch.h>


//void coremap_create();
void
vm_bootstrap(void)
{	
	//kprintf("bootstrap vm & coremap \n");
	coremap_create();
}


/* Allocate/free some kernel-space virtual pages */
vaddr_t 
alloc_kpages(int npages)
{
	//kprintf("alloc_kpages called, allocating %d pages...\n", npages);
	paddr_t pa;
	pa = getppages(npages);
	if (pa==0) {
		kprintf("alloc_kpages failed\n");
		return 0;
	}
	
	return PADDR_TO_KVADDR(pa);
}

void 
free_kpages(vaddr_t addr)
{
	//kprintf("free_kpages called, free pages...\n");
	paddr_t paddr = KVADDR_TO_PADDR(addr);
	releasepages(paddr);
	(void)addr;
}


int
vm_fault(int faulttype, vaddr_t faultaddress)
{
	//vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
	
	paddr_t paddr;
	
	u_int32_t ehi, elo;
	struct addrspace *as;
	//int spl;
	int i;
	//spl = splhigh();
	//kprintf("Address triger fault: %x\n", faultaddress);
	faultaddress &= PAGE_FRAME;
	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);

	//switch (faulttype) {
	 //   case VM_FAULT_READONLY:
		/* We always create pages read-write, so we can't get this */
	//	panic("dumbvm: got VM_FAULT_READONLY\n");
	//    case VM_FAULT_READ:
	//    case VM_FAULT_WRITE:
	//	break;
	//    default:
	//	splx(spl);
	//	return EINVAL;
	//}
	if(faulttype == VM_FAULT_WRITE ||VM_FAULT_READ )
	{
		as = curthread->t_vmspace;
		if (as == NULL)
		 {
		/*
		 * No address space set up. This is probably a kernel
		 * fault early in boot. Return EFAULT so as to panic
		 * instead of getting into an infinite faulting loop.
		 */
			kprintf("No address space set up!\n");
			return EFAULT;
		  }


		struct pagetableentry* pte;
		for (i = 0; i < array_getnum(as->pagetable); i++)
		{
			pte = array_getguy(as->pagetable, i);
			if (pte->vaddr == faultaddress)
			{
	
				//kprintf("Entering first if \n");
				//kprintf("The valid bit of pte is %d\n", pte->valid);
				if(pte->valid == 0)
				{
					paddr = getppages(1);
					//kprintf("entry not valid, assign paddr %x\n",paddr);
					if (paddr == 0)
					{
						return ENOMEM;
					}
					pte->paddr = paddr;
					pte->valid = 1;
					if (as->as_pbase1 == 0 && faultaddress >= as->as_vbase1 && faultaddress < as->as_vbase1 + as->as_npages1 * PAGE_SIZE)
					{
						as->as_pbase1 = paddr;
					}
					if (as->as_pbase2 == 0 && faultaddress >= as->as_vbase2 && faultaddress < as->as_vbase2 + as->as_npages2 * PAGE_SIZE)
					{
						as->as_pbase2 = paddr;
					}
					if (as->as_stackpbase == 0 && faultaddress >= USERSTACK - VM_STACKPAGES * PAGE_SIZE && faultaddress < USERSTACK)
					{
						as->as_stackpbase = paddr;
					}
					break;
				}
				else
				{
					paddr = pte->paddr;
					break;
				}
				
			}
		}
		if (i == array_getnum(as->pagetable) && pte->vaddr != faultaddress)
		{		
			kprintf("The virtual adress is imagnary return error");	
			//splx(spl);
			return ENOMEM;
 		}
	
	}

	ehi = faultaddress;
	elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
	
	//DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
	//kprintf("add paddr %x into TLB \n",paddr);
	TLB_Random(ehi, elo);
	//splx(spl);
	return 0;
	/* Assert that the address space has been set up properly. */
/*
	assert(as->as_vbase1 != 0);
	assert(as->as_pbase1 != 0);
	assert(as->as_npages1 != 0);
	assert(as->as_vbase2 != 0);
	assert(as->as_pbase2 != 0);
	assert(as->as_npages2 != 0);
	assert(as->as_stackpbase != 0);
	assert((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
	assert((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
	assert((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
	assert((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
	assert((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);

	vbase1 = as->as_vbase1;
	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
	vbase2 = as->as_vbase2;
	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
	stackbase = USERSTACK - VM_STACKPAGES * PAGE_SIZE;
	stacktop = USERSTACK;

	if (faultaddress >= vbase1 && faultaddress < vtop1) {
		paddr = (faultaddress - vbase1) + as->as_pbase1;
	}
	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
		paddr = (faultaddress - vbase2) + as->as_pbase2;
	}
	else if (faultaddress >= stackbase && faultaddress < stacktop) {
		paddr = (faultaddress - stackbase) + as->as_stackpbase;
	}
	else {
		splx(spl);
		return EFAULT;
	}
*/
	/* make sure it's page-aligned */
	//assert((paddr & PAGE_FRAME)==paddr);


	//kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
	//splx(spl);
	//return EFAULT;
}












